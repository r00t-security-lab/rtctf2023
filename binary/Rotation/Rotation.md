# 解题思路

注：由于IDA版本的不同，反编译的结果也会有些微不同，但从结构上分析应是相同的思路。

简单介绍下总体思路：

程序中存储了一个长度为16的数组：

![1](.\1.png)

但其实这个数组里的值都小于256，所以只用到了八个比特位。

而通过第一个if判断语句可以得知我们的输入长度也为16：

![image-20230511155544506](.\2.png)

下面来看看第一个循环

## 第一个for循环

![image-20230511155813446](.\3.png)

每次循环都会得到一个v14，总共产生8个

而每次循环会进行8次while循环

### 分析while

注：加粗部分请思考理解，欢迎随时向xyy师傅提问



可以看到while中每次取我们输入的一个字符v9（从第零个到第七个）

利用v9和v8作与操作，而v8为2^i，可以理解为取v9的i+1个比特位

```c
v13 = (v9 & (unsigened _int8)v8) ！=0
```

**这句语句应理解为v13是一个二进制数，当v9与v8相与的结果不为0，则返回一个布尔值1，反之返回0**

最后再将v13左移v16个比特位，用v14**加上**这个值

而可以看到v16在while循环中取值为7至0正好对应一个字节有八个比特位



综合一下，可以理解为将输入的str数组中每个元素第i+1个比特位取出，**第0个元素的放最高位，第7个元素的放最低位**，这样就可以构成一个八个比特位的字节组成v14



那么回到for循环，可以将思路总结为以下过程：

将我们输入的前八个字符纵向排列（**第七个在最下方，第零个在最顶端**）

然后按比特位横向展开。

**我们就可以得到一个8*8矩阵**，将这个矩阵**逆势针旋转**90度，可以得到一个新的矩阵，将矩阵横向作为比特位得到一个字节，进而得到八个字符，这个新的矩阵便是我们这个for循环的结果

## 第二个for循环

![image-20230511162750869](.\4.png)

总体上逻辑和第一个类似，只是细节有所区别

可以看到从输入中取值的顺序变成了从尾部向前，v4的取值顺序也和v8相反了。

类比上一题的逻辑我们可以总结出：

将输入的后八个字符纵向排列（**第十五个再底端，第八个在顶端**）

按比特位展开得到8*8矩阵，**顺势针旋转**90度，可以得到一个新的矩阵

，同第一个循环，又得到八个字符

## 第三个for循环

![image-20230511164055244](.\5.png)



经上两个循环我们得到16个字符，与预期的字符串长度吻合，所以可以得出结论这里是在用我们得到的字符与原本存储在程序中的字符比对，若正确则我们的输入便是flag

那么我们只需要利用逆向思维，将题目中存储的字符串，按判断的顺序和上文的方法，切分为两个8*8矩阵，上方的顺时针旋转，下方的逆时针旋转，就可以得到flag辣！

flag:**r00t{n1ganm4, aiy0u!!!}**



```
n: 01101110
1: 00110001
g: 01100111
a: 01100001
n: 01101110
m: 01101101
4: 00110100
,: 00101100

a: 01100001
i: 01101001
y: 01111001
0: 00110000
u: 01110101
!: 00100001
!: 00100001
!: 00100001
```







